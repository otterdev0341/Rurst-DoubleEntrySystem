use jsonwebtoken::{encode, Header, EncodingKey};
use serde::{Serialize, Deserialize};
use std::time::{SystemTime, UNIX_EPOCH};

// Define the claims (payload) structure
#[derive(Serialize, Deserialize)]
struct Claims {
    sub: String,           // Subject (e.g., user ID)
    exp: usize,            // Expiration time
}

fn generate_jwt(secret_key: &str, user_id: &str) -> Result<String, Box<dyn std::error::Error>> {
    // Set the expiration time to 60 minutes from now
    let expiration_time = SystemTime::now()
        .duration_since(UNIX_EPOCH)?
        .as_secs() + 3600;

    // Create the claims
    let claims = Claims {
        sub: user_id.to_string(),
        exp: expiration_time as usize,
    };

    // Create the encoding key using the secret key
    let encoding_key = EncodingKey::from_secret(secret_key.as_ref());

    // Encode the JWT
    let token = encode(&Header::default(), &claims, &encoding_key)?;

    Ok(token)
}

fn main() {
    let secret_key = "your_secret_key";
    let user_id = "user123";

    match generate_jwt(secret_key, user_id) {
        Ok(token) => println!("Generated JWT: {}", token),
        Err(e) => eprintln!("Error generating JWT: {}", e),
    }
}
